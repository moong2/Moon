---
layout: post
title: "알고리즘 문제해결기법 입문 문제6D"
date: 2021-02-21
excerpt: "Python 알고리즘 문제해결기법 입문 문제6D"
tags: [Python, 알고리즘 문제해결기법 입문, Chapter.6]
comments: true
---
# 6D

### 문제
N명의 사람이 원 모양으로 둥글게 앉아있으며, 각각 시계방향으로 1~N번의 번호를 부여받는다고 하자. 아래와 같은 규칙으로 사람들을 제외해 나간다.

- 가장 처음에는 1번 사람이 지목된다.
- 이후 시계방향으로 다음 사람이 지목된다.
- 이를 반복하다가 M번째로 지목받은 사람을 제외한다. 그 이후 제외 된 사람의 다음 사람부터 위의 과정을 반복해 나간다.

예를 들어서 N=7이고 M=3인 경우를 생각해보자.

- 초기에는 { 1, 2, 3, 4, 5, 6, 7}처럼 사람들이 앉아있다.
- 3번째로 지목되는 3번을 제외하여 { 1, 2, 4, 5, 6, 7 }이 남으며 4번부터 게임을 다시 시작한다.
- 차례로 4, 5, 6번 사람이 지목받아 3번째로 지목받은 6번이 게임에서 제외되므로 { 1, 2, 4, 5, 7 }의 사람이 남아 게임을 다시 시작한다.
- 차례로 7, 1, 2번 사람이 지목받아 3번째로 지목받은 2번이 게임에서 제외되므로 {1, 4, 5, 7 }의 사람이 남아 게임을 다시 시작한다.
- ...


위와 같은 과정을 반복한다고 하자. N과 M이 주어졌을 때 각 번호의 사람들이 게임에서 제외되는 순서대로 출력하는 프로그램을 작성하시오.

### 입력 형식
첫 줄에는 테스트케이스의 수를 나타내는 10이하의 자연수 T가 주어진다. 이후 총 T개에 대한 입력이 차례로 주어진다.

각 테스트케이스의 입력은 한 줄로 N M형식으로 주어진다. 

- N은 사람의 수를 나타내는 5,000이하의 자연수다.
- M은 사람을 제외해 나갈 간격을 나타내는 5,000이하의 자연수다.

### 출력 형식
각 테스트케이스별로 한 줄에 정답을 출력한다.

- N명의 사람들의 번호를 제외 된 순서대로 출력한다.
- 각 번호는 공백으로 구분한다. 

### 예시 1
#### 입력
{% highlight css %}
2
4 2
7 3
{% endhighlight %}
#### 출력
{% highlight css %}
2 4 3 1
3 6 2 7 5 1 4
{% endhighlight %}

### 예시 2
#### 입력
{% highlight css %}
10
200 50
199 199
198 448
197 797
196 1246
195 1795
194 2444
193 3193
192 4042
191 4991
{% endhighlight %}
#### 출력
{% highlight css %}
50 100 150 200 51 102 153 4 56 108 160 12 65 118 171 24 78 132 186 40 95 151 7 63 120 176 32 89 146 5 64 123 181 39 99 161 20 81 141 2 67 128 190 53 116 180 44 110 174 38 106 172 37 107 175 43 113 183 52 124 193 66 136 9 80 154 26 98 177 54 130 6 83 159 35 119 197 77 158 41 126 10 90 173 61 145 30 122 13 96 189 79 168 68 156 49 144 42 139 33 137 31 138 36 143 48 155 62 167 76 188 94 11 121 29 157 74 194 111 27 163 86 14 135 72 199 133 73 8 148 91 25 182 125 82 22 185 140 101 60 21 195 166 134 112 93 84 69 57 47 46 55 59 75 92 109 131 165 192 19 88 147 196 70 149 16 115 3 127 28 178 114 71 18 1 198 17 58 105 170 87 184 152 129 162 191 104 85 103 187 179 97 142 164 15 169 34 117 45 23
199 1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190 17 41 65 90 116 143 170 2 38 72 106 140 176 19 60 101 144 185 37 85 132 181 40 94 148 5 68 126 186 56 121 184 61 130 4 82 157 39 118 197 89 172 69 156 52 147 48 146 51 155 67 169 88 196 117 35 161 92 16 142 81 18 154 100 44 188 138 99 57 14 177
{% endhighlight %}

# 풀이

### 설명
처음에는 deque를 이용하려다가 파이썬이 제공하는 리스트로 충분할 것 같아서 리스트를 이용했습니다. 큰 틀은 리스트에 들어있는 원소가 없을 때 까지리스트에서 m만큼 떨어진 숫자들을 연속적으로 삭제해나가는 것 입니다. 파이썬은 pop을 기본 메소드로 제공하기 때문에 이를 이용하면 쉽게 해결할 수 있습니다. remove를 0으로 초기화 하고, 이 remove에 m을 더해 제거할 인덱스를 구합니다. 이 때 원순열처럼 돌면서 원소를 삭제해야하므로 현재 리스트의 길이를 나누어주어 마지막 원소의 다음으로 첫번째 원소를 접근할 수 있도록 합니다. 이 제거한 원소는 따로 리스트에 저장해서 관리할 수 있는데 이 문제에서는 그저 출력만 해 주면 되므로 따로 메모리를 쓰지 않고 바로 출력을 해 주었습니다. 출력 방식이 두 가지가 있는데 이는 마지막 출력에 띄어쓰기가 되어 있으면 fail이 뜨기 때문에 이렇게 나누어 조건을 달았습니다. 

### 코드
{% highlight css %}
import sys

t = int(input())
for _ in range(t):
	n, m = map(int, sys.stdin.readline().split())
	people_li = [i for i in range(1, n+1)]
	remove = 0
	while(len(people_li) > 0) :
		remove = (remove + m - 1) % len(people_li)
		remove_person = people_li.pop(remove)
		if(len(people_li) == 0) :
			print(remove_person)
		else :
			print(remove_person, end=' ')
{% endhighlight %}

### 기타
- `Memory` : 9864
- `Time` : 0.046