---
layout: post
title: "BAEKJOON 14659"
date: 2021-02-22
excerpt: "Python BAEKJOON PROBLEM 14659"
tags: [Python, BAEKJOON, Greedy, BRONZE2]
comments: true
---

# 14659

### 문제
“반갑다. 내 이름은 반고흐#31555! 조선 최고의 활잡이지. 오늘도 난 금강산 위에서 적들을 노리고 있지. 내 앞에 있는 적들이라면 누구도 놓치지 않아! 좋아, 이제 곧 월식이 시작되는군. 월식이 시작되면 용이 적들을 집어삼킬 것이다. 잘 봐두어라! 마장동 활잡이 반고흐#31555님의 실력을-!”

반고흐#31555는 자기 뒤쪽 봉우리에 덩기#3958이 있음을 전혀 모르고 있었다. 덩기#3958도 반고흐#31555와 마찬가지로 월식이 시작되면 용을 불러내어 눈앞에 있는 다른 활잡이들을 모두 처치할 생각이다. 사실, 반고흐#31555와 덩기#3958 뿐만 아니라 금강 산맥의 N개 봉우리에 있는 모든 활잡이들이 같은 생각을 가지고 있다.

반고흐#31555가 있는 금강 산맥에는 총 N개의 봉우리가 있고, 모든 봉우리마다 한 명의 활잡이가 서서 월식이 시작되기만을 기다리고 있다. 다만, 애석하게도, 천계에 맥도날드가 생겨 용들이 살이 찐 탓에 용들은 자신보다 낮은 봉우리에 서있는 적들만 처치할 수 있게 되었다. 또한 용들은 처음 출발한 봉우리보다 높은 봉우리를 만나면 그대로 공격을 포기하고 금강산자락에 드러누워 낮잠을 청한다고 한다. 봉우리의 높이는 모두 다르고 모든 용들은 오른쪽으로만 나아가며, 중간에 방향을 틀거나, 봉우리가 무너지거나 솟아나는 경우는 없다.

“달에 마구니가 끼었구나.”

드디어 월식이 시작됐다! 과연 이들 활잡이 중 최고의 활잡이는 누구일까? 최고의 활잡이가 최대 몇 명의 적을 처치할 수 있는지 알아보자.

### 입력 형식
첫째 줄에 봉우리의 수 겸 활잡이의 수 N이 주어진다. (1 ≤ N ≤ 30,000) 둘째 줄에 N개 봉우리의 높이가 왼쪽 봉우리부터 순서대로 주어진다. (1 ≤ 높이 ≤ 100,000) 각각 봉우리의 높이는 중복 없이 유일하다.

### 출력 형식
최고의 활잡이가 처치할 수 있는 적의 최대 숫자를 출력한다.

### 예시 1
#### 입력
{% highlight css %}
7
6 4 10 2 5 7 11
{% endhighlight %}
#### 출력
{% highlight css %}
3
{% endhighlight %}

# 풀이

### 설명
스택을 이용해 이용할 가치가 있는 정보만 남겨놓는 방식을 이용했다. 이용할 가치가 있는 정보로는 현재 가장 높은 봉우리의 정보가 있다. 

처음에는 스택에 아무 내용이 없기 때문에 첫 봉우리는 스택에 저장을 한다. 다음 봉우리부터는 스택의 top에 있는 봉우리의 높이와 크기 비교를 해서 현재 봉우리가 더 클 때 더 큰 봉우리가 나올 때 까지 스택에 있는 봉우리들을 pop한다. 만일 스택이 비게 된다면 현재까지 더 큰 봉우리가 없다는 뜻을 의미한다. 그리고 봉우리를 pop할 때 마다 처치한 수를 계산하는데 도움을 줄 start_point를 업데이트한다. 

지금 코드는 pop할 때마다 계산을 하지만 조건을 둔다면 반복문 밖에서 해당 작업을 진행할 수 있을 것이다. 다만, 이 문제를 푸는데 시간, 공간복잡도 상에 무리가 없기 때문에 이렇게 진행을 했다. 

처음 이렇게 제출을 했을 때 '틀렸습니다'가 떴는데 이는 내림차순으로 봉우리의 정보가 들어왔을 때를 고려하지 않았기 때문에 발생했다. 예를 들어

> 7
10 9 8 7 6 5 4

라는 정보가 입력되었을 때, 전에 입력된 봉우리의 수가 더 크기 때문에 pop작업이 0번 들어가게 되고 그렇게 되면 당연히 답도 오답이 된다. 이럴 때 뿐만 아니라 현재 스택에 남아있는 정보들로 계산한 답이 max_kill에 저장되어 있는 답보다 클 경우가 존재할 것이다.

그래서 반복문을 빠져나오면 답을 한번 더 구해주는 방식을 적용했다.
스택의 맨마지막에 저장된 정보와 처음 저장된 정보만 가지고 계산을 해 비교해주면 된다. 만일 스택에 정보가 하나만 들어있다고 하더라도 max_kill과 0을 비교하는 꼴이 되기 때문에 답은 달라지지 않는다.

현재 코드에서는 len(peaks_stack)-1을 인덱스로 계산해서 구하는 방식을 적용했는데 애초에 deque를 이용하는 방법도 있다. 하지만 자료구조 상 스택을 이용하고 싶었기 때문에 기본 리스트로 작성을 했다.

### 코드
{% highlight css %}
import sys

n = int(input())
peaks = list(map(int, sys.stdin.readline().split()))
peaks_stack = list()
max_kill = 0
for i, elem in enumerate(peaks) :
    end_point = i
    while(len(peaks_stack) != 0 and elem >= peaks_stack[-1][1]) : 
        peak = peaks_stack.pop()
        start_point = peak[0]
        max_kill = max(max_kill, end_point - start_point)
    peaks_stack.append((i+1, elem))
max_kill = max(max_kill, peaks_stack[len(peaks_stack)-1][0] - peaks_stack[0][0])
print(max_kill)
{% endhighlight %}

### 기타
- `Memory` : 33136KB
- `Time` : 100ms