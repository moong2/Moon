---
layout: post
title: "알고리즘 문제해결기법 입문 문제3A"
date: 2021-02-14
excerpt: "Python 알고리즘 문제해결기법 입문 문제3A"
tags: [Python, 알고리즘 문제해결기법 입문, Chapter.3]
comments: true
---
# 3A

### 문제
용돈이 필요해진 지수는 한 설문조사 기관에서 아르바이트를 하게 되었다. 지수는 수 많은 사람들에게 전화를 통해 설문조사를 하는 일을 맡게 되었는데, 어느 날 휴식시간에 문득 사람들이 전화번호 뒷자리로 가장 많이 사용하는 번호는 무엇인지 궁금해졌다. 하지만 지수는 보유한 전화번호가 너무 많고, 전화번호의 뒷자리는 0000~9999의 총 1만가지의 종류가 있기에 눈으로 세는 것은 도저히 불가능할 것이라는 판단을 내렸다. 지수를 위하여 사람들의 전화번호 뒷자리 중 가장 많이 사용되는 번호를 찾아주자.

### 입력 형식
가장 첫 줄에 전화번호의 수 N이 1이상 10만 이하의 자연수로 주어진다.

그 후 총 N줄에 걸쳐서 공백없이 4개의 자연수로 구성 된 전화번호 뒷자리가 한 줄에 하나씩 주어진다. 전화번호 뒷자리는 0000~9999사이 중 하나이다.

### 출력 형식
주어진 전화번호 뒷자리들 중 가장 많이 등장한 번호를 출력한다. 0을 포함하여 공백없는 네 자리 숫자로 출력해야한다.

단, 등장한 횟수가 같은 번호가 두 개 이상인 경우 가장 사전순으로 빠른 숫자를 출력한다.

### 예시 1
#### 입력
{% highlight css %}
3
1234
4321
1234
{% endhighlight %}
#### 출력
{% highlight css %}
1234
{% endhighlight %}

### 예시 2
#### 입력
{% highlight css %}
2
4321
1234
{% endhighlight %}
#### 출력
{% highlight css %}
1234
{% endhighlight %}

# 풀이

### 설명
이중 반복문을 써도 되지만 그렇게 코드를 짤 시 시간이 많이 걸린다는 단점이 있습니다. 전화번호는 총 9999개가 나올 수 있기 때문에 전화번호 각각을 저장할 cnt배열을 9999자리 할당해 줍니다. 전화번호 각각은 cnt배열의 인덱스라고 할 수 있습니다. 그리고 현재 모든 인덱스에 해당하는 값을 0으로 초기화합니다. 다음, 데이터 배열을 돌며 전화번호를 얻어와 cnt배열에서 +1을 합니다. 가장 빈번한 전화번호를 찾는 것은 cnt배열에서 가장 큰 값을 가진 인덱스에 해당합니다. 따라서, for문을 돌며 가장 큰 value를 가진 인덱스를 찾아 max_index에 업데이트하고 차후 이를 출력합니다. 문제에서 등장한 횟수가 같은 번호일 경우 사전순으로 빠른 숫자를 출력하라고 했으므로, 해당 인덱스의 value가 max_index의 value보다 작거나 같을 경우에는 업데이트를 하지 않는 방식으로 진행했습니다. 시간복잡도는 O(min(N, 10000))입니다.

### 코드
{% highlight css %}
n = int(input()) #전화번호의 수 
data = [] # 각 전화번호의 뒷자리 
for i in range(n):
	num = int(input())
	data.append(num)
	
cnt = [0] * 10000 #cnt[XXXX] := 뒷 자리가 XXXX인 전화번호의 수 
for elem in data :
	cnt[elem] += 1


max_index = 0 #가장 많이 등장한 뒷자리 후보 
for num in range(10000): #모든 뒷자리에 대하여 
	if cnt[num] > cnt[max_index]: 
		max_index = num

print("%04d" % max_index ) 
{% endhighlight %}

### 기타
- `Memory` : 12442
- `Time` : 0.187