---
layout: post
title: "BAEKJOON 17626"
date: 2021-03-06
excerpt: "Python BAEKJOON PROBLEM 17626"
tags: [Python, BAEKJOON, Greedy, BRONZE1]
comments: true
---

# 17626

### 문제
선물 포장 공장을 말아먹은 욱제는 계곡에서 백숙을 파느라 학교에 자주 가지 못한다. 하지만 월클의 인생은 피곤한 법! 욱제는 지금처럼 힘든 시기에도 자신을 기다리는 5조5억명의 열렬한 팬들을 위해 가끔씩 학교에 가 줘야 한다. 욱제는 백숙이 끓는 걸 지켜봐야 해서 가게를 오래 비울 수 없다. 그래서 욱제는 한 번 학교에 간 뒤 최소 시간동안 머물다가 모든 팬들과 한 번씩 인사를 하고 학교를 떠나려고 한다.

욱제는 임의의 시각에 학교에 오거나 학교를 떠날 수 있고, 단 한 번의 왕복만 한다. 동시에 여러 팬들에게 인사를 끝낼 수도 있다. 욱제는 잘생겨서 인사하면 팬들이 심쿵사로 바로 쓰러지기 때문에 인사를 하는데 소요되는 시간은 0이라고 하자.

예를 들어 3명의 팬 A, B, C가 학교에 머무르는 시간이 <그림 1>과 같다고 하자. 이 경우 시각 2에 3명의 팬이 모두 학교에 있으므로, 욱제는 시각 2에 학교에 와서 3명에게 동시에 인사를 하고 바로 가게로 돌아갈 수 있다. 시각 3이나 4도 마찬가지이다. 이때 욱제가 학교에 머무는 시간의 총합은 0이다.

다른 예로 2명의 팬 A와 B가 학교에 있는 시간이 <그림 2>와 같다고 하자. 욱제는 시각 4부터 시각 5까지 학교에 머물면서 시각 4에 A와, 시각 5에 B와 인사를 하고 학교를 떠날 수 있다. 이때 욱제가 학교에 머무는 시간은 1이다.

백숙집 주방 이모 효빈이는 N명의 팬들이 학교에 머무르는 시간 [s, e]들을 몰래 조사했다. 효빈이는 욱제가 학교에 머무르는 시간을 계산해서 그 시간동안 땡땡이를 치기로 했다. 효빈이와 함께 욱제가 학교에 머무르는 최소의 시간을 계산해 보자!

### 입력 형식
첫째 줄에 욱제의 열렬한 팬의 수 N이 주어진다. (1 ≤ N ≤ 100,000)

둘째 줄부터 N개의 줄에 걸쳐, 각 줄에 정수 si, ei (1 ≤ si ≤ ei ≤ 100,000)가 순서대로 주어진다. 이는 i번째 팬이 학교에 있는 시간 [si, ei]을 의미한다.

### 출력 형식
욱제가 학교에 머물러야 하는 최소의 시간을 출력한다.

### 예시 1
#### 입력
{% highlight css %}
3
2 5
1 4
2 4
{% endhighlight %}
#### 출력
{% highlight css %}
0
{% endhighlight %}

### 예시 2
#### 입력
{% highlight css %}
2
1 4
5 6
{% endhighlight %}
#### 출력
{% highlight css %}
1
{% endhighlight %}

# 풀이

### 설명
가장 늦게 등교하는 학생의 등교시간과 가장 빨리 하교하는 학생의 하교 시간을 구하면 되는 문제다. 
구하려는 등교시간이 구하려는 하교시간보다 작을 경우, 학생들은 모두 겹치는 시간에 학교에 있었다는 것이 되므로 욱제가 인사하는 시간은 0이 된다.
반대의 경우, 구하려는 하교시간에서 구하려는 등교시간을 빼 주면 된다.

처음에는 구간을 모두 저장하는 코드를 이용했다. 그러면서 코드도 길어지고, 변수도 많아졌다. 
돌아가는 것 같으면서도 당연하게 반례가 존재했다.

구간과 구간이 겹쳐치지 않는다면 그 구간을 저장해야겠다고 생각했지만, 위처럼 가장 빨리 하교하는 시간과 가장 늦게 등교하는 시간을 구하면 끝나는 문제다.
가장 빨리 하교하는 시간을 구하기 위해서 해당 변수인 fastest_leaving_time이 가질 수 있는 가장 큰 시간으로 초기화를 해 주었다.
문제에서 구간의 최댓값은 100000이라고 했으므로 fastest_leaving_time을 해당 값으로 초기화시키고, latest_attending_time은 가장 늦게 등교하는 시간인 1로 초기화를 하면 되지만 0도 상관없어서 0으로 초기화를 했다.

가장 빨리 하교하는 시간은 입력받은 하교시간이 fastest_leaving_time보다 작을 때 업데이트 해 준 값이다.
가장 늦게 등교하는 시간은 입력받은 등교시간이 latest_attending_time보다 클 때 업데이트 해 준 값이다.

살짝 헷갈릴 수 있는 점이 '가장 빨리'를 구하기 위해 최댓값에서 내려와야하고, '가장 늦게'를 구하기 위해 최솟값에서 올라가야 하는 것이다.

### 코드
{% highlight css %}
import sys

n = int(input())
latest_attending_time = 0
fastest_leaving_time = 100000

for i in range(n) :
    s, e = map(int, sys.stdin.readline().split())
    if(s > latest_attending_time) : latest_attending_time = s
    if(e < fastest_leaving_time) : fastest_leaving_time = e

if(latest_attending_time - fastest_leaving_time < 0) : print(0)
else : 
    print(latest_attending_time - fastest_leaving_time)
{% endhighlight %}

### 기타
- `Memory` : 28776KB
- `Time` : 168ms