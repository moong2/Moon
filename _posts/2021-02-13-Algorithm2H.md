---
layout: post
title: "알고리즘 문제해결기법 입문 문제2H"
date: 2021-02-13
excerpt: "Python 알고리즘 문제해결기법 입문 문제2H"
tags: [Python, 알고리즘 문제해결기법 입문, Chapter.2]
comments: true
---
# 2H

### 문제
컴퓨터는 이미지 정보를 2차원 배열 형태로 저장한다. 하지만 현실의 사물들의 모양을 그대로 저장하는 것은 불가능하다. 정밀한 이미지를 저장할수록 더 많은 공간과 연산량을 필요로 하기 때문이다. 영상을 구성하는 하나의 픽셀은 정사각형 형태로 존재하며 이 픽셀들이 모여 2차원 배열의 모양을 구성하게 된다.

반지름이 5픽셀인 원을 비트맵 형태로 저장하면 위와 같다. 그림에서 알 수 있는 것 처럼 실제로 원에 포함되는 픽셀들은 아래와 같은 특징을 가진다.

- 네 점이 모두 원 안에 존재하거나
- 원과 겹치는 영역이 존재하면서 두개 이상의 변이 원의 외곽선과 교차한다.

그렇다면 반지름이 임의의 R픽셀인 원이 포함하는 픽셀의 수를 계산하는 프로그램을 작성해보자.

### 입력 형식
이 문제는 여러 개의 테스트케이스로 구성되어있다. 첫 줄에는 테스트케이스의 수를 나타내는 1이상 10이하의 자연수 T가 주어진다.

각 테스트 케이스는 한 줄로 구성되며 계산하고자 하는 원의 반지름의 픽셀 수 R이 주어진다. R은 1이상 10만 이하의 자연수이다.

### 출력 형식
각 테스트케이스를 두 줄에 걸쳐서 출력한다. 

- 테스트케이스의 첫 줄에는 테스트 케이스의 번호를 #1, #2, #3, ... 형태로 출력한다
- 테스트케이스의 두 번째 줄에는 반지름이 R픽셀인 원이 포함하는 픽셀의 수를 출력한다.

### 예시 1
#### 입력
{% highlight css %}
2
1
5
{% endhighlight %}
#### 출력
{% highlight css %}
#1
4
#2
88
{% endhighlight %}

### 예시 2
#### 입력
{% highlight css %}
10
100000
99999
99998
99997
99996
99995
99994
99993
99992
99991
{% endhighlight %}
#### 출력
{% highlight css %}
#1
31416325412
#2
31415696920
#3
31415069480
#4
31414441300
#5
31413811792
#6
31413184112
#7
31412555868
#8
31411927608
#9
31411299368
#10
31410671260
{% endhighlight %}

# 풀이

### 설명
1사분면의 픽셀을 세서 *4를 합니다. 픽셀이 포함되는 최소 조건으로는 두 개 이상의 변이 원의 외곽선과 교차하는 것입니다. 이를 위해서는 1사분면의 픽셀이라면 (x, y-1)의 점과 원점과의 거리가 원의 반지름보다 작아야합니다. 또 1사분면에서는 x의 값이 커질수록 픽셀의 수는 줄어듭니다. 그리고 이중 반복문을 통해 픽셀을 세는 것은 시간 효율성이 떨어지므로 h라는 변수를 둬서 픽셀의 높이를 저장해두고 h부터 거리계산을 했습니다. 픽셀이 원에 포함되지 않을 때, h를 1씩 줄여갔고, 계산이 끝난 이후에는 해당 x좌표에 대한 픽셀의 수를 sum_pixel에 더해 업데이트를 했습니다. 시간복잡도는 O(N+@)이므로 O(N)입니다.

### 코드
{% highlight css %}
def find_pixel(r) :
	sum_pixel = 0
	h = r
	for i in range(r) :
		while(((i**2) + (h-1)**2) >= r**2) : h -= 1
		sum_pixel += h
	return sum_pixel*4

t = int(input())
for i in range(1, t+1) :
	print("#%d" %i)
	print(find_pixel(int(input())))
{% endhighlight %}

### 기타
- `Memory` : 9423
- `Time` : 0.99