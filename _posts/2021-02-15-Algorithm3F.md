---
layout: post
title: "알고리즘 문제해결기법 입문 문제3F"
date: 2021-02-15
excerpt: "Python 알고리즘 문제해결기법 입문 문제3F"
tags: [Python, 알고리즘 문제해결기법 입문, Chapter.3]
comments: true
---
# 3F

### 문제
인기 아이돌 코들리즈(Codelyz)의 매니저인 당신은 코들리즈의 팬 사인회를 기획하고 있다. 원래의 계획대로라면 팬들이 구매한 앨범의 시리얼 넘버를 추첨하여 팬 사인회 초대권을 증정할 계획이었지만, 얼마 전(문제3C)에 있었던 중복응모사건으로 인하여 다른 방법을 찾아야만 했다.

이 번에 당신이 준비한 방법은 다음과 같다.

- 당신은 미리 N개의 숫자카드들을 선정하여 임의의 순서대로 배치해두었다.
- 숫자카드의 순서는 바뀌지 않으며, 숫자에 적힌 숫자와 별개로 1번 카드, 2번 카드, ... 로 번호를 붙였다.
- 각 카드에는 32비트 정수형 범위에 해당하는 숫자가 적혀있다. 다만 앨범을 구매하기 전 팬들에게 공개하지 않는다.
- 앨범은 한 사람 당 한 번만 구매할 수 있으며, 앨범을 구매한 사람은 1과 N사이의 두 자연수 L과 R을 고를 수 있다. (단, 1<= L <= R<=N)
- 앨범을 구입한 팬은 자신이 정한 L~R번 카드에 적힌 숫자들의 합 만큼 점수를 얻는다.

예를 들어서 총 5개의 카드에 차례로 {1, -1, 5, 2, 3 } 가 적혀 있었다면, < L=2, R=4 >로 두 숫자를 정한 팬은 { (-1) + 5 + 2 } 점을 얻는 것이다. 

당신은 기획한 대로 앨범을 구매한 M명의 팬들이 정한 두 숫자들을 앨범을 구매한 순서대로 파일로 정리했다. 이 중에서 높은 점수를 가진 팬 부터 차례로 선정해 팬 사인회 초대장을 보내려고 한다. 그렇다면 가장 먼저 초대장을 받게 될 사람은 몇 번째로 앨범을 구매한 팬일까? 

### 입력 형식
첫 번째 줄에 숫자카드의 수와 앨범을 구매한 팬의 수를 나타내는 자연수 N과 M이 공백으로 구분되어 주어진다. N과 M은 모두 1이상 10만 이하의 자연수이다.

두 번째 줄에는 숫자카드에 적혀진 총 N개의 32비트 정수가 공백으로 구분되어 주어진다. 

그 후 총 M줄에 걸쳐서 앨범을 구매한 순서대로 팬이 선택한 두 숫자 L과 R이 공백으로 구분되어 주어진다. L과 R은 모두 1이상 N 이하의 자연수이다. L은 항상 R이하의 값을 가짐이 보장된다. 

### 출력 형식
한 줄에 가장 먼저 초대장을 받게 될 사람이 앨범을 구매한 순서와 얻은 점수를 공백으로 구분하여 출력한다. 같은 점수를 얻은 사람이 존재 할 경우 먼저 구매한 사람을 기준으로 출력한다.

### 예시 1
#### 입력
{% highlight css %}
5 2
1 -1 5 2 3
2 4
1 3
{% endhighlight %}
#### 출력
{% highlight css %}
1 6
{% endhighlight %}

### 예시 2
#### 입력
{% highlight css %}
10 5
1 -1 5 2 3 1 -1 5 2 3
1 2
2 3
3 4
4 5
5 6
{% endhighlight %}
#### 출력
{% highlight css %}
3 7
{% endhighlight %}

# 풀이

### 설명
각 앨범에 써져 있는 정수의 합을 더해 놓은 배열을 선언했습니다. 해당 배열은 각 앨범에 써져 있는 정수 배열의 현재 인덱스까지의 합을 가지고 있는 배열로 i값의 value는 i-1 + 현재 i의 앨범의 정수에 해당합니다. 처음에는 이 배열의 크기를 n으로 할당하고 0번째 값에 정수 배열의 0번째 인덱스 값을 저장을 했는데 이렇게 하면 같은 값의 l과 r이 들어왔을 때 전혀 다른 값이 나온다는 것을 깨달았습니다. 그렇기 때문에 range_sum 배열을 n+1만큼 할당을 해주고 0번째에는 0값을 넣어 값의 변화가 없게 설정했습니다. 시간복잡도는 O(N)입니다.

### 코드
{% highlight css %}
n, m = map(int, input().split())
card = list(map(int, input().split()))
range_sum = [0] * (n+1)
range_sum[0] = 0
for i in range(1, n+1) :
	range_sum[i] = range_sum[i-1] + card[i-1]

max_index = -1
for i in range(m) :
	l, r = map(int, input().split())
	score = range_sum[r] - range_sum[l-1]
	if(max_index == -1) :
		max_score = score
		max_index = i + 1
	else :
		if(score > max_score) :
			max_score = score
			max_index = i + 1
print(max_index, max_score)
{% endhighlight %}

### 기타
- `Memory` : 18207
- `Time` : 0.31