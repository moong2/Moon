---
layout: post
title: "알고리즘 문제해결기법 입문 문제3B"
date: 2021-02-14
excerpt: "Python 알고리즘 문제해결기법 입문 문제3B"
tags: [Python, 알고리즘 문제해결기법 입문, Chapter.3]
comments: true
---
# 3B

### 문제
한 아이돌 그룹은 2집 앨범 발매 기념 콘서트를 열기로 하였다. 이 콘서트의 기획을 맞게 된 당신은 2집 앨범의 컨셉트에 맞게 콘서트장을 알록달록하게 꾸미고자 한다. 하지만 디자인 감각이 전혀 없던 당신은 어떻게하면 예쁘고 불규칙적으로 알록달록하게 색상을 배치할 수 있을지 고민을 하고있다. 당신은 콘서트장에 한 줄로 배치 된 좌석들 중 연속된 몇 칸을 골라 한 가지 색으로 색칠하고, 또 다른 연속된 몇 칸을 골라 색칠하는 과정을 반복하기로 하였다. 

처음에 모든 좌석은 하얀색(0번 색상)으로 색칠되어 있으며, 당신은 연속 된 몇 칸의 좌석을 골라서 한 가지 색으로 칠할 수 있다.  당신은 0번부터 99번까지 총 100가지 색상을 사용할 수 있다. 0번은 항상 흰색이라고 가정한다. 그러므로 가장 처음에 모든 좌석은 0번 색상으로 색칠되어 있다. 색깔과 색칠할 연속 된 좌석들을 선택하면 해당 좌석들은 모두 같은 색으로 칠해진다. 의자를 칠하는 페인트들은 순식간에 마르므로 두 가지 이상의 색상이 섞이는 일은 벌어지지 않는다.

예를 들어서 좌석이 1번부터 10번까지 있다고 하자.  2번부터 5번까지의 좌석을 빨간색으로 색칠하고, 그 후 4번부터 7번까지의 좌석을 파란색으로 색칠하면 결과적으로 2~3번 좌석은 빨간색, 4~7번 좌석은 파란색이 된다. 그리고 나머지 좌석들은 흰색이 된다. 

당신은 이렇게 불규칙적으로 좌석들을 색칠한 후, 가장 많은 좌석이 가진 색과 반대로 가장 적은 좌석이 가진 색의 번호를 찾고자 한다. 단, 마지막에 아무 좌석에도 칠해져 있지 않은 색상은 제외한다. 두 색의 번호를 찾을 수 있는 프로그램을 작성해보자.

### 입력 형식
첫 줄에는 좌석의 수 N과 색칠을 할 방법의 수 M이 차례로 주어진다. N과 M은 모두 1,000 이하의 자연수이다.

이후 M줄에 걸쳐서 공백으로 구분된 세 정수가 주어진다. 모든 규칙은 수행되는 순서대로 주어진다. 즉, 먼저 입력된 색칠 규칙이 먼저 적용된다.

- 첫 번째 수자는 색칠할 가장 왼쪽(번호가 작은) 좌석의 번호이다. 
- 두 번째 숫자는 색칠할 가장 오른쪽(번호가 큰) 좌석의 번호이다.
- 세 번째 숫자는 좌석에 칠할 색깔의 번호이다.

단, 좌석의 번호는 1과 N사이의 자연수이며. 색깔의 번호는 0이상 99이하의 정수이다.

### 출력 형식
첫 번째 줄에 가장 많은 좌석이 칠해진 색의 번호를 출력한다. 

두 번째 줄에 가장 적은 좌석이 칠해진 색의 번호를 출력한다.

조건을 만족하는 색이 두 개 이상이라면 번호가 작은 색을 출력한다.

### 예시 1
#### 입력
{% highlight css %}
10 2
2 5 1
4 7 2
{% endhighlight %}
#### 출력
{% highlight css %}
0
1
{% endhighlight %}

### 예시 2
#### 입력
{% highlight css %}
10 2
1 9 5
2 10 5
{% endhighlight %}
#### 출력
{% highlight css %}
5
5
{% endhighlight %}

# 풀이

### 설명
전화번호 문제(3A)와 비슷한 문제입니다. 먼저, 입력을 받고 n자리 할당된 seats배열에 left부터 right까지 color값을 value로 지정해줍니다. 색은 덮어쓰기가 된다고 했으므로 현재 seats배열에 무슨 색이 있던지간에 업데이트 해줍니다. 색은 총 100가지 있을 수 있으므로 색의 번호를 인덱스로 가지는 100개의 자리가 할당된 table배열을 선언합니다. seats배열을 돌며 value값(색 번호)을 인덱스로 하는 table의 value를 +1씩 해줍니다. 가장 빈번한 색과 가장 빈번하지 않은 색의 인덱스를 참조하는 변수로 max_color_idx, min_color_idx를 각각 지정해주었고 -1로 초기화를 했습니다. table변수의 0번째 값으로 할당을 하고 이후 반복문을 1번째부터 돌리는 방식을 택했었는데 이럴 경우 table의 0번째 값에 해당하는 value가 0일 경우 오류가 발생하기 때문에 -1로 초기화를 하고 반복문을 돌 때 조건으로 -1이거나 최대, 최소 조건을 만족할 때로 설정했습니다. 시간복잡도는 O(min(m, 100))입니다.

### 코드
{% highlight css %}
n, m = map(int, input().split())
seats = [0] * n
for _ in range(m) :
	left, right, color = map(int, input().split())
	for i in range(left-1, right) : seats[i] = color

table = [0] * 100
for elem in seats :
	table[elem] += 1

max_color_idx = -1
min_color_idx = -1
for i in range(0, 100) :
	if(table[i] != 0) :
		if(max_color_idx == -1 or table[i] > table[max_color_idx]) : max_color_idx = i
		if(min_color_idx == -1 or table[i] < table[min_color_idx]) : min_color_idx = i

print(max_color_idx)
print(min_color_idx)
{% endhighlight %}

### 기타
- `Memory` : 9389
- `Time` : 0.036