---
layout: post
title: "BAEKJOON 12782"
date: 2021-03-18
excerpt: "Python BAEKJOON PROBLEM 12782"
tags: [Python, BAEKJOON, Greedy, SILVER5]
comments: true
---

# 12782

### 문제
진홍이는 숫자를 좋아한다. 오늘도 숫자를 가지고 놀던 진홍이는 두 숫자의 비트 우정지수를 구해보았다. 비트 우정지수란, 10진법으로 나타낸 두 정수를 이진수로 나타내었을 때, 두 숫자를 같게 만드는데 필요한  최소 연산 횟수를 말한다. 연산의 종류는 다음과 같다.

1. 하나의 이진수에서 임의의 자리의 숫자를 0 또는 1로 바꾼다.
2. 하나의 이진수에서 서로 다른 자리에 있는 두 숫자의 위치를 바꾼다.

예를 들어, 10진수 11과 12의 비트 우정지수를 구해보자. 11을 이진수로 나타내면 1011이고, 12를 이진수로 나타내면 1100이다. 1011에서 2의 자리를 0으로 바꾸고(1011 -> 1001), 1의 자리와 4의 자리의 숫자를 서로 바꾸면(1001 -> 1100) 1100이 된다. 즉, 1011을 1100으로 바꾸는 최소 연산 횟수는 두 번으로, 11과 12의 비트 우정지수는 2가 된다.

진홍이는 어떤 두 수가 주어졌을 때 두 수의 비트 우정지수를 구하는 프로그램을 만들고 싶다. 하지만, 아쉽게도 진홍이는 프로그래밍에 약해 10진수를 이진수로 바꾸는 것 밖에 하지 못한다. 여러분이 진홍이를 도와 두 수의 비트 우정지수를 구하는 프로그램을 만들어 주자!

### 입력 형식
입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 50)가 주어진다.

각 테스트케이스의 첫 번째 줄에는 두 이진수 N, M이 주어진다. N, M의 자릿수는 1,000,000을 넘지 않으며, 자릿수는 서로 같다.

### 출력 형식
각 테스트 케이스마다 두 수의 비트 우정지수를 출력한다.

### 예시 1
#### 입력
{% highlight css %}
3
1011 1100
100101 110100
00110100 10010111
{% endhighlight %}
#### 출력
{% highlight css %}
2 
1
3
{% endhighlight %}

# 풀이

### 설명
n과 m 중 n을 m에 맞춘다고 가정하면 n의 각각의 비트에서 해야 할 일은 

1. 1을 0으로 바꾼다.
2. 0을 1로 바꾼다.

이 두 가지다.
그렇기 때문에, 이 두 가지 경우를 수행해야 하는 각각의 수를 찾는다. 코드에서 1번의 경우 fixes[0]에 저장했고, 반대의 경우 fixes[1]에 저장했다.

답은 fixes[0]과 fixes[1] 중 큰 값이다. fixes[0]과 fixes[1]의 최솟값은 문제 조건에서 2번을 수행할 수 있는 정도이다. 그렇기 때문에 둘 중 작은 값은 계산에 직접적인 영향을 주지 않는 데이터로 간주할 수 있다. max(fixes[0], fixes[1]) - min(fixes[0], fixes[1])은 문제에서 1번을 수행해야 하는 값이다.
즉, min(fixes[0], fixes[1]) + max(fixes[0], fixes[1]) - min(fixes[0], fixes[1])이 되므로 답은 max(fixes[0], fixes[1])이다.

### 코드
{% highlight css %}
import sys

t = int(input())
for _ in range(t) :
    n, m = sys.stdin.readline().split()
    fixes = [0 for i in range(2)]

    for i in range(len(n)) :
        if(n[i] != m[i]) :
            if(n[i] == '1') : fixes[0] += 1
            else : fixes[1] += 1
    
    print(max(fixes[0],fixes[1]))
{% endhighlight %}

### 기타
- `Memory` : 28776KB
- `Time` : 264ms